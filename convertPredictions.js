/** convertPredictions
 * @module convertPredictions
 * @desc Used for converting the predictions generated by the model to
 * a format that can be used in CytoBrowser.
 */

const fs = require("fs");
const fsPromises = fs.promises;
const parse = require("csv-parse/lib/sync");

// Regular expressions for parsing info from file names
const indexFinder = /i\d+j\d+/;
const iFinder = /(?<=i)\d+/;
const jFinder = /(?<=j)\d+/;
const idFinder = /(?<=i\d+j\d+_)\d+(?=_z-?\d+\.jpg$)/;
const zFinder = /(?<=z)-?\d+(?=\.jpg$)/;

// TODO: Should be able to set these
const WIDTH = 10;
const HEIGHT = 10;

function createEntryFromZLevel(filename) {
    const index = filename.match(indexFinder)[0];
    const i = Number(index.match(iFinder)[0]);
    const j = Number(index.match(jFinder)[0]);
    const id = Number(filename.match(idFinder)[0]);
    const z = Number(filename.match(zFinder)[0]);
    return {i: i, j: j, id: id, z: z};
}

function createEntriesFromZLevels(name, dir) {
    return fsPromises.readdir(dir).then(content => {
        const fns = content.filter(n => {
            return n.startsWith(name) && n.endsWith(".jpg");
        });
        const entries = fns.map(createEntryFromZLevel);
        return entries;
    });
}

function getCsvData(dir, fns) {
    const data = [];
    fns.forEach(filename => {
        const path = `${dir}/${filename}`;
        const csvData = fs.readFileSync(path);
        const objectData = parse(csvData, {columns: true});
        const index = filename.match(indexFinder)[0];
        const i = Number(index.match(iFinder)[0]);
        const j = Number(index.match(jFinder)[0]);
        objectData.forEach(detection => {
            data.push({
                i: i,
                j: j,
                x: Number(detection["X"]),
                y: Number(detection["Y"]),
                id: Number(detection[" "]) - 1 // -1 to match Z file names
            });
        });
    });
    return data;
}

function mergeEntriesWithCsvData(entries, csvData) {
    entries.forEach(entry => {
        const match = csvData.find(d =>
            d.i === entry.i
            && d.j === entry.j
            && d.id === entry.id
        );
        if (match) {
            entry.x = match.x;
            entry.y = match.y;
        }
    });
}

function addCsvDataToEntries(name, dir, entries) {
    return fsPromises.readdir(dir).then(content => {
        const fns = content.filter(n => {
            return n.startsWith(name) && n.endsWith(".csv");
        });
        const csvData = getCsvData(dir, fns);
        mergeEntriesWithCsvData(entries, csvData);
        return entries;
    });
}

function adjustEntryOffsets(entries) {
    entries.sort((a, b) => a.i < b.i || a.j - b.j);
    entries.forEach((entry, id) => {
        entry.id = id;
        entry.x = entry.x + WIDTH * entry.j;
        entry.y = entry.y + HEIGHT * entry.i;
    });
    return entries;
}

function convertResultsToEntries(name, zDir, csvDir) {
    return createEntriesFromZLevels(name, zDir)
        .then(entries => addCsvDataToEntries(name, csvDir, entries))
        .then(adjustEntryOffsets)
}

function convertEntriesToObject(entries) {
    const output = {
        id: [],
        x: [],
        y: [],
        z: [],
        mclass: [],
        certainty: []
    };
    entries.forEach(entry => {
        output.id.push(entry.id);
        output.x.push(entry.x);
        output.y.push(entry.y);
        output.z.push(entry.z);
        output.mclass.push("TODO");
        output.certainty.push(1);
    });
    return output;
}

function convertResultsToObject(name, zDir, csvDir) {
    return convertResultsToEntries(name, zDir, csvDir)
        .then(convertEntriesToObject);
}

exports.getCsvData = getCsvData;
exports.convertResultsToEntries = convertResultsToEntries;
exports.convertResultsToObject = convertResultsToObject;
/*
// Some info can be parsed from the filename itself
function parseImageInfo(filenames) {
    const entries = filenames.map(fn => {
        const index = fn.match(indexFinder)[0];
        const i = Number(index.match(iFinder)[0]);
        const j = Number(index.match(jFinder)[0]);
        return {i: i, j: j, filename: fn};
    });
    return entries.sort((a, b) => a.i < b.i || a.j - b.j);
}

function readPredictions(name, dir) {
    return fsPromises.readdir(dir).then(content => {
        const fns = content.filter(n => {
            return n.startsWith(name) && n.endsWith(".csv")
        });
        const entries = parseImageInfo(fns);
        entries.forEach(entry => {
            entry.path = `${dir}/${entry.filename}`;
            const csvData = fs.readFileSync(entry.path);
            entry.data = parse(csvData, {columns: true});
        });
        return entries;
    });
}

function csvDataEntriesToArray(entries) {
    const output = {id: [], x: [], y: []};
    entries.forEach(entry => {
        const offsetX = entry.j * WIDTH;
        const offsetY = entry.i * HEIGHT;
        entry.data.forEach(prediction => {
            output.id.push(output.id.length);
            output.x.push(Number(prediction["X"]) + offsetX);
            output.y.push(Number(prediction["Y"]) + offsetY);
        });
    });
    return output;
}

function convertResultToObject(name, dir) {
    return readPredictions(name, dir).then(csvDataEntriesToArray);
}

function convertResultToJson(names, csvDir, outputDir) {
    names.forEach(name => {
        convertResultsToObject(name, csvDir).then(result => {
            const outputFile = `${outputDir}/${name}.json`;
            const resultText = JSON.stringify(result);
            fsPromises.writeFile(outputFile, resultText);
        });
    });
}

exports.parseImageInfo = parseImageInfo;
exports.readPredictions = readPredictions;
exports.convertResultToObject = convertResultToObject;
exports.writeResultsAsJson = writeResultsAsJson;
exports.convertResultsToJson = convertResultsToJson;
*/
