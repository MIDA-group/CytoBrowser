/**
 * @module convertPredictions
 * @desc Used for converting the predictions generated by the model to
 * a format that can be used in CytoBrowser.
 */

const fs = require("fs");
const fsPromises = fs.promises;
const parse = require("csv-parse/lib/sync");

// Regular expressions for parsing info from file names
const indexFinder = /i\d+j\d+/;
const iFinder = /(?<=i)\d+/;
const jFinder = /(?<=j)\d+/;
const idFinder = /(?<=i\d+j\d+_)\d+(?=_z-?\d+\.jpg$)/;
const zFinder = /(?<=z)-?\d+(?=\.jpg$)/;

// TODO: Should probably be able to set these more flexibly
const WIDTH = 6496;
const HEIGHT = 3360;

function createEntryFromZLevel(filename) {
    const index = filename.match(indexFinder)[0];
    const i = Number(index.match(iFinder)[0]);
    const j = Number(index.match(jFinder)[0]);
    const id = Number(filename.match(idFinder)[0]);
    const z = Number(filename.match(zFinder)[0]);
    return {i: i, j: j, id: id, z: z};
}

function createEntriesFromZLevels(name, dir) {
    return fsPromises.readdir(dir).then(content => {
        const fns = content.filter(n => {
            return n.startsWith(name) && n.endsWith(".jpg");
        });
        const entries = fns.map(createEntryFromZLevel);
        return entries;
    });
}

function getCsvData(dir, fns) {
    const data = [];
    fns.forEach(filename => {
        const path = `${dir}/${filename}`;
        const csvData = fs.readFileSync(path);
        const objectData = parse(csvData, {columns: true});
        const index = filename.match(indexFinder)[0];
        const i = Number(index.match(iFinder)[0]);
        const j = Number(index.match(jFinder)[0]);
        objectData.forEach(detection => {
            data.push({
                i: i,
                j: j,
                x: Number(detection["X"]),
                y: Number(detection["Y"]),
                id: Number(detection[" "]) - 1 // -1 to match Z file names
            });
        });
    });
    return data;
}

function mergeEntriesWithCsvData(entries, csvData) {
    entries.forEach(entry => {
        const match = csvData.find(d =>
            d.i === entry.i
            && d.j === entry.j
            && d.id === entry.id
        );
        if (match) {
            entry.x = match.x;
            entry.y = match.y;
        }
    });
}

function addCsvDataToEntries(name, dir, entries) {
    return fsPromises.readdir(dir).then(content => {
        const fns = content.filter(n => {
            return n.startsWith(name) && n.endsWith(".csv");
        });
        const csvData = getCsvData(dir, fns);
        mergeEntriesWithCsvData(entries, csvData);
        return entries;
    });
}

function adjustEntryOffsets(entries) {
    entries.sort((a, b) => a.i < b.i || a.j - b.j);
    entries.forEach((entry, id) => {
        entry.id = id;
        entry.x = entry.x + WIDTH * (entry.j - 1); // Offset results if no -1, for some reason
        entry.y = entry.y + HEIGHT * (entry.i - 1);
    });
    return entries;
}

function convertResultsToEntries(name, zDir, csvDir) {
    return createEntriesFromZLevels(name, zDir)
        .then(entries => addCsvDataToEntries(name, csvDir, entries))
        .then(adjustEntryOffsets)
}

function convertEntriesToObject(entries) {
    const output = {
        id: [],
        x: [],
        y: [],
        z: [],
        mclass: [],
        certainty: []
    };
    entries.forEach(entry => {
        output.id.push(entry.id);
        output.x.push(entry.x);
        output.y.push(entry.y);
        output.z.push(entry.z);
        output.mclass.push("Other");
        output.certainty.push(1);
    });
    return output;
}

/**
 * Convert prediction results to an object format that can be used for
 * the visualization of predictions. This function assumes results have
 * already been generated, and takes the directories where the results
 * can be found as input, alongside the name of the image to be converted.
 * @param {string} name The name of the image whose results should be
 * converted to an object.
 * @param {string} zDir The directory wherein the image patches can be
 * found after focus selection.
 * @param {string} csvDir The directory wherein csv files with cell
 * nucleus detection information can be found.
 * @returns {Promise} A promise that resolves with the object
 * representation of the given image's prediction results.
 */
function convertResultsToObject(name, zDir, csvDir) {
    return convertResultsToEntries(name, zDir, csvDir)
        .then(convertEntriesToObject);
}

exports.convertResultsToObject = convertResultsToObject;
