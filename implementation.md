# Implementation details

The implementation of CytoBrowser can be divided into two main parts: the server side and the client side. As the server is small in its current state, the server files are all located in the root directory. The client files can be found in `public/`, and the client-side JavaScript code makes heavy use of the [reveal module](https://gist.github.com/zcaceres/bb0eec99c02dda6aac0e041d0d4d7bf2) pattern for encapsulation. This document describes a few key aspects of the system, what modules they use, and how they are connected.

## Initialization

The following section describes how the server is started, and what happens when a client connects to it.

### Starting the server

Before the CytoBrowser client can be opened, the server has to be started. The server is run with [Node.js](https://nodejs.org/en/), which will have to be installed first. The server also uses a couple of Node modules, which can be installed with [npm](https://www.npmjs.com/) by running the command `npm install`. With the modules installed, the server can be started with the command `node cytobrowser.js [address] [port]`, which specifies which interface the server should listen on. When starting the server, two more command line arguments, `-d` and `-s`, can be provided to specify directories for the image data and the server storage. For example, running `node cytobrowser.js -d ./data -s ./storage 127.0.0.1 8080` starts a server on `127.0.0.1:8080` with image data in `./data` and storage data in `./storage`.

A couple of things happen when the server is started. It sets up endpoints for client requests, including WebSocket endpoints for collaboration. It also sets up three directories for static files that the client can read, two of which are the data and storage directories, and the third of which is `./public`. It also initializes the different modules that will be used.

### Opening the client

The client can be opened once the server has been started. As `./public` is being statically served by the server, going to the address specified when starting the server will open up `./public/index.html`. This page loads all the necessary client-side javascript, and then runs a short script once it has been loaded. The script calls the `initUI()` function in `.public/js/tmappUI.js` to set up the parts of the user interface that need to be added programmatically, and also calls the `init()` function in `./public/js/tmapp.js` in order to initialize the OpenSeadragon instance.

Before calling `tmapp.init()`, the script in `./public/index.html` looks at the search parameters specified in the URL. These are sent as arguments to `tmapp.init()` in order to specify the initial state of the viewer, the collaboration being joined, and the image being opened. 

The `tmapp.init()` begins by making a GET request to the `api/images` endpoint on the server. This endpoint provides a JSON response that describes all the images available in the data directory specified when starting the server. The information described by these images are the image names, the different z levels available for them, and the paths to two images that can be used as thumbnails when previewing the image. The server finds this information programmatically using the module `availableImages.js`. Once this information has been retrieved by the client, the image information is stored in `tmapp`, `tmappUI.updateImages()` is called to set up the images in the image browser, and any actions necessitated by the URL search parameters, i.e. opening an image or joining a collaboration, are carried out.

## Opening an image

The client-side `tmapp` module contains the function `openImage()`, which should be used whenever the image has to be changed. This function uses data retrieved in `tmapp.init()` to get get information about the specified image. It is called by `tmapp.init()` if an image name has been specified in the search parameters, but it is also called when a new image is selected in the image browser, when a collaborator changes an image, or when a file is loaded for data on another image. Since these can be very different situations that require the function to do different things once the image has been opened, the function includes a parameter for a callback function. For instance, if a viewport position has been specified when calling `tmapp.init()`, the callback function will tell the viewport to move to the specified position once the image has been loaded.

The first thing that happens when calling the `openImage()` function is that it checks if any annotations have been placed on the current image. If they have, it asks the user if they actually want to change images. If the user rejects, the third parameter of `openImage()` specifies another callback function that should be called if the user doesn't want to change images. This is used to disconnect from a collaboration when the image is opened by another collaborator but the local user doesn't want to change.

The function goes on to clear data from the current image before calling the internal function `_initOSD`, which initiates the OpenSeadragon instance. This includes setting up event handlers, initiating the overlays, and loading the image files. When setting up the event handlers, the callback function mentioned earlier is set to be called after an `"open"` event has fired. 

## Placing annotations

Annotations are manually placed through the module `annotationTool`. This module is called both through mouse event handlers specified in `tmapp` as well as by keyboard shortcuts specified in `tmappUI`. Internally, this module defines an `_activeTool`, which is a closure that exposes a number of functions for different tool actions. For instance, clicking in the viewport calls the `click()` function of the module itself, which in turn calls the `click()` function of whichever tool is active. If the marker tool is active it creates a new marker, if the polygon tool is active it adds a new corner to the polygon, etc. Once a tool has been used to complete an annotation, it calls the `annotationHandler` module. The region selection tools also contain calls to the `overlayHandler` module in order to give the user feedback on the region pending creation.

The `annotationHandler` module is the central module for handling annotations. It should be called whenever annotations are added, updated, removed or cleared. As mentioned, it is called when the `annotationTool` module creates a new annotation, but it is also called when a collaborator places an annotation, when annotations are loaded from a file, or when a user first joins a collaboration. This module contains the canonical state of the currently existing annotations, which is stored in the internal array `_annotations`. The public functions for this module contain the parameters `coordSystem` and `transmit`. The `coordSystem` specifies which of the three [OpenSeadragon coordinate systems](https://openseadragon.github.io/examples/viewport-coordinates/) the annotation points are being defined with. These are always converted to image coordinates when storing the annotations. The `transmit` parameter specifies whether or not the annotation action should be transmitted to collaborators. This is used to avoid loops. For example, one collaborator will add an annotation with `transmit` set to `true`, which will be broadcast to all other collaborators, causing them to add annotations with `transmit` set to `false`.

The representation of annotations in the `annotationHandler` module does not make any distinction between markers and regions. This difference is only present in the `annotationTool` and the `overlayHandler` modules. The annotations contain an array of points used to specify their coordinates. If there is only one point in the array, it is seen as a marker, else it is seen as an annotation. This makes it simpler to work with the annotations in places where the distinction is unimportant.

As the `annotationHandler` updates the current state of the annotations, it calls the `annotationVisuals` module in order to give the user a visual representation of the annotations. This module uses [d3](https://d3js.org/) to update the list of annotations in the user interface. The coordinates specified for the annotations in this list are their centroids. Note that the function used for calculating the centroid of a polygon in the current state of the system does not work properly for self-intersecting polygons. The `annotationHandler` module also calls the `overlayHandler` module in order to display annotations in the viewport.

## Saving and loading annotations

The system can be used to save and load annotations, both locally and on the server. When storing annotations on the server, they are stored in the storage directory specified when starting the server.

### Local storage

There are two important modules for local storage, `annotationStorageConversion` and `localStorage`. Both of these are called from the `tmappUI` module based on user input. The `annotationStorageConversion` contains two public functions, one for getting an object representation of all currently placed annotations, and one for taking such an object and adding the annotations specified to the current image. This object also contains the name of the image, so that the user can be moved to the right image when loading annotations. The `localStorage` module is responsible for converting between JSON files and JavaScript objects on the local machine. When saving a file, `annotationStorageConversion.getAnnotationStorageData()` is first called to get an object, and `localStorage.saveJSON()` is called to store the object locally. When loading a file, `localStorage.loadJSON()` is called to get the object, and `annotationStorageConversion.addAnnotationStorageData()` is called to convert it into annotations.

### Remote storage

On the client side, remote storage uses the `remoteStorage` module for communicating with the server, but still uses `annotationStorageConversion` to convert between objects and annotations. An important difference is the additional use of the `fileBrowserUI` module, which contains the necessary functionality for browsing server files, selecting which ones to load, selecting file versions, and so on. This module does not directly communicate with the server to get file information, but instead gets an object representation of the storage directory by calling `remoteStorage.files()`. 

When the function `remoteStorage.files()` is called, a GET request is sent to the `api/storage` endpoint of the server. This is routed to the `files()` function in the `serverStorage` module, which recursively traverses the storage directory in order to find subdirectories and files. This information is collected into an object and sent back to the requester. The function also takes into account the versioning system used for the system.

Saving files with `remoteStorage.saveJSON()` calls the `api/storage` endpoint with a POST request. The request includes search parameters that contain the filename, the path, whether or not the file should overwrite any other files with the same name, and whether or not the file should be added as a new version of a file with the versioning system. The body of the request contains the actual data being stored. When the `serverStorage` module processes this request, it sanitizes both the path and the filename to avoid null characters, path traversal, etc. It also makes sure that the filename is nonempty, that it has the `.json` file extension, that the specified directory exists, and that it does not try to circumvent the versioning system. Loading a file from the server is much simpler. As the storage directory is statically served by the server, the client can simply read the file directly from the path. 

#### Versioning system

Storage on the server includes a simple versioning system based on file names. When a file is added with a given name, the server checks if that name already exists in the file system. If it does exist, and both the `overwrite` and `reversion` search parameters are set to 0, the response to the client has the status code `300`, and the client prompts the user for whether they want to overwrite the file, add a new version of the file, or cancel. If the user chooses to overwrite the file, nothing special happens, and the file on the server is simply replaced. If the user chooses to add a new version of the file, the old file is renamed, and the new file is saved with the old name. The name of the most recent version of the file is always the same as the user typed it. Older versions are given the prefix `__version_n__`, where `n` is `1` for the oldest version and increases by `1` for each new version. When loading an older version of a file from the server, `remoteStorage.loadJSON()` adds this prefix on the client side.

## Collaboration

Collaboration done through the `collabClient` module on the client side. Initiating a collaboration is done either through `collabClient.createCollab()` or `collabClient.connect()`, the difference being that `collabClient.createCollab()` first sends a GET request to the server's `api/collaboration/id` endpoint to get a short, unused id for the collaboration. When connecting, the client opens a WebSocket to the server's `/collaboration` endpoint. The user can choose to include their currently placed annotations when creating a new collaboration, in which case an empty array called `_joinBatch` is initialized and stored internally in the module. Before the client can start getting information from the server, it calls the internal function `_requestSummary()` to get a summary of the current state of the system.

The messages sent over the collaboration are all encoded as JSON, and are handled with the internal function `_handleMessage()`. The messages all contain a `type` field to specify which kind of message it is, and the first message a client will receive always has the type `"summary"`. The summary message contains information about what annotations have already been placed, what members are participating in the collaboration, and what image is being looked at. If the current image is different from the image used in the collaboration, the `_joinBatch` variable is set to `null` and another request is sent. Once the client receives a summary message with the same image, the initialization can continue.

If the `_joinBatch` variable is truthy when the initialization continues, i.e. if it is an empty array, all the locally stored annotations are pushed to it. The messages received in the summary message are then added locally through the `annotationHandler` module. This is followed by the annotations in `_joinBatch` being re-added. This ensures that if an annotation from the collaboration and a local collaboration have the same id, the local one will be reassigned before being sent out to other collaborators. 

Once the collaboration has been initialized, the `collabClient` module simply sends out messages and handles incoming messages. When a local user performs an action that other collaborators should be aware of, such as placing an annotation or moving their viewport, messages are sent over the websocket to other collaborators, and the other collaborators' `collabClient` modules call the appropriate functions when they receive the messages. In order to move to a collaborator's viewpoint, information sent through `memberEvent` messages are used to find the right parameters. When following another member's view, the view is simply moved automatically whenever such a message is received.

The server side of collaboration is handled in the `collaboration` module. This module stores one collaboration object per open collaboration. Whenever a client tries to connect to a collaboration that does not exist yet, it is created, and the client is added as a member. The collaboration objects contain information about all the currently stored annotations and all the members connected to the collaboration. One important detail is that each member object contains a `ready` property, which specifies whether or not they are on the right image and have received the summary. If this is not the case, messages will not be forwarded to them until they are.

## OpenSeadragon overlay

The `overlayHandler` module is used for everything shown in the overlay, including annotations and cursors. A lot of the work is done using [d3](https://d3js.org/), which takes care of figuring out which annotations are new, which ones have been removed, which ones are being updated, and so on. This module is called by both `annotationVisuals` when the annotations are updated, as well by `collabClient` whenever a collaborator moves their cursor. The module adds mouse tracking to annotations in order to allow things like dragging or right-clicking for comments. 

The different elements being displayed in the overlay are dependent on the current state of the viewport. For instance, cursors are always the same size, and the text next to markers are always the right way around. In order to accomplish this, event handlers are added to the OpenSeadragon viewer whenever the viewport is zoomed or rotated, and these handlers call `overlayHandler.setOverlayRotation()` and `overlayHandler.setOverlayScale()` in order to properly handle the adjustments to overlay elements.

When the active annotation tool is changed through `tmappUI`, it also calls `overlayHandler.setActiveAnnotationOverlay()` to show this to the user. When this function is called for the marker tool, mouse events for regions are disabled, and when it's called for regions, mouse events for markers are disabled. This allows the user to for example place markers inside a region without accidentally dragging the region instead.
